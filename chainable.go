/*
Package chainable provides an easy and convenient way of chaining function calls in Golang.

Basics

It's common to find Go programs similar to the one below:

	x, err := sum2(2)
	if err != nil {
		return 0, err
	}

	y, err = mul2(x)
	if err != nil {
		return 0, err
	}

	z, err = div2(y)
	if err != nil {
		return 0, err
	}

	return z, nil

Error handling can make the codebase messy. At the same time, chaining function calls can obfuscate
errors and cascading calls can increase the cognitive complexity.

Elixir, F# and other languages solve this problem with the support to pipes, but Golang hasn't such
feature.

Chainable provides a clearer way to chain function calls, using the output of the previous function
as the input of the next one. The example above could be re-written using Chainable as follow:

	import (chainable "github.com/mauricioklein/go-chainable")

	res, err := chainable.New().
		From(2).
		Chain(
			sum2,
			mul2,
			div2,
		).
		Unwrap()

	// "Unwrap" returns the result as a slice of Argument, matching the return values
	// of the last function. So, we just need to cast them to the correct type
	z := res[0].(int)

Another advantage is that Chainable automatically handle errors in a chain.
Thus, if one of the methods returns an error as the last argument, the chain is broken
and the error is returned by the "Unwrap" method:

	raiseError := func ()      (int, error) { return 0, errors.New("generic error") }
	plus2      := func (x int)              { return x + 2 }

	chainable.New().
		Chain(raiseError). // breakes the chain
		Chain(plus2).      // never called
		Unwrap()           // returns nil, "a generic error"

If automatic error handling isn't desired (i.e. the error should be chained along with the other arguments),
the method "ChainDummy" should be used instead of "Chain". Pay attention that the next function in the chain
must be able to receive the error generated by the previous one:

	raiseError    := func ()               (int, error) { return 2, errors.New("generic error") }
	plus2AndError := func (x int, e error) (int)        { return x + 2 }

	chainable.New().
		ChainDummy(raiseError).
		Chain(plus2AndError).
		Unwrap() // returns []Argument{4}, nil

"Chain" and "DummyChain" methods are variadics, and can be used in conjunction:

	chainable.New().
		Chain(f1).       // error handling enabled for f1
		ChainDummy(f2).  // error handling disabled for f2
		Chain(f3, f4).   // error handling enabled for f3 and f4
		Unwrap()

Finally, to reset a chain and make it ready to be reused, just call the method "Reset":

	chain := chainable.New()

	... use of chain

	chain.Reset()
*/
package chainable

import (
	"reflect"
)

// Function defines a function added to the chain
type Function interface{}

// Argument defines an argument provided to the functions in a chain
type Argument interface{}

// Chainable defines the chain logic.
type Chainable struct {
	from  []Argument
	links []link
}

// link represents a function in a chain
type link struct {
	fn          Function
	handleError bool
}

// New instantiate a new Chainable instance
func New() *Chainable {
	return &Chainable{}
}

// From defines the arguments provided to the first
// function in a chain
func (c *Chainable) From(args ...Argument) *Chainable {
	c.from = args
	return c
}

// Chain appends a new function to the chain, with error
// handling enabled
func (c *Chainable) Chain(funcs ...Function) *Chainable {
	c.addFuncs(funcs, true)
	return c
}

// ChainDummy appends a new function to the chain, with error
// handling disabled
func (c *Chainable) ChainDummy(funcs ...Function) *Chainable {
	c.addFuncs(funcs, false)
	return c
}

// Unwrap process the chain.
// It returns a []Argument with the arguments returned by the last function in the chain (or nil, if the chain is broken)
// and an error, returned by any of the functions in the chain with error-handling enabled (or nil, if success)
func (c *Chainable) Unwrap() ([]Argument, error) {
	v := c.from
	var err error

	for linkIndex, link := range c.links {
		if v, err = link.process(linkIndex, v); err != nil {
			return nil, err
		}
	}

	return v, nil
}

// Reset cleanups a chain, removing all
// the links and initial values
func (c *Chainable) Reset() *Chainable {
	c.from = []Argument{}
	c.links = []link{}

	return c
}

// addFuncs add new functions to the chain, creating the underlying link
func (c *Chainable) addFuncs(funcs []Function, handleError bool) {
	for _, fn := range funcs {
		c.links = append(c.links, link{
			fn:          fn,
			handleError: handleError,
		})
	}
}

// process calls the function fn associated to the link, transforming args using reflection
func (lk *link) process(linkIndex int, args []Argument) ([]Argument, error) {
	vfn := reflect.ValueOf(lk.fn)
	if err := validateFunc(linkIndex, vfn); err != nil {
		return nil, err
	}

	vfnType := vfn.Type()
	if err := validateArgs(linkIndex, vfnType, args); err != nil {
		return nil, err
	}

	// call the function
	out := []Argument{}
	for _, o := range vfn.Call(reflectArgs(args)) {
		out = append(out, o.Interface())
	}

	// if the last returned value for the function
	// is an error, cast the error and return it
	// along with the rest of values
	if lk.handleError && doesReturnError(vfnType) {
		err, _ := out[len(out)-1].(error)
		return out[:len(out)-1], err
	}

	return out, nil
}

// validateFunc validates if obj is a function
func validateFunc(linkIndex int, obj reflect.Value) error {
	// Zero value reflected: not a valid function
	if obj == (reflect.Value{}) {
		return notAFunctionError(linkIndex)
	}

	if obj.Type().Kind() != reflect.Func {
		return notAFunctionError(linkIndex)
	}

	return nil
}

// validateFuncArgs validates if len(args) matches the arity of fn
func validateArgs(linkIndex int, fn reflect.Type, args []Argument) error {
	if !fn.IsVariadic() && (fn.NumIn() != len(args)) {
		return argumentMismatchError(linkIndex, len(args), fn.NumIn())
	}

	return nil
}

// reflectArgs transforms the args list in a list of
// reflect.Value, used to call a function using reflection
func reflectArgs(args []Argument) []reflect.Value {
	in := make([]reflect.Value, len(args))

	for k, arg := range args {
		in[k] = reflect.ValueOf(arg)
	}

	return in
}

// doesReturnError returns true if the last return
// value for vfn is a type error
func doesReturnError(vfnType reflect.Type) bool {
	return vfnType.Out(vfnType.NumOut()-1) == reflect.TypeOf((*error)(nil)).Elem()
}
