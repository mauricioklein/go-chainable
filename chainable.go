/*
Package chainable provides an easy and convenient way of chaining function calls in Golang.

Basics

It's common to find Go programs similar to the one below:

	x, err := sum2(2)
	if err != nil {
		return 0, err
	}

	y, err = mul2(x)
	if err != nil {
		return 0, err
	}

	z, err = div2(y)
	if err != nil {
		return 0, err
	}

	return z, nil

Error handling can make the codebase messy. At the same time, chaining function calls can obfuscate
errors and cascading calls can increase the cognitive complexity.

Elixir, F# and other languages solve this problem with the support to pipes, but Golang hasn't such
feature.

Chainable provides a clearer way to chain function calls, using the output of the previous function
as the input of the next one. The example above could be re-written using Chainable as follow:

	import (chainable "github.com/mauricioklein/go-chainable")

	res, err := chainable.New().
		From(2).
		Chain(
			sum2,
			mul2,
			div2,
		).
		Unwrap()

	// "Unwrap" returns the result as a slice of interface{}, matching the return values
	// of the last function. So, we just need to cast them to the correct type
	z := res[0].(int)

Another advantage is that Chainable automatically handle errors in a chain.
Thus, if one of the methods returns an error as the last argument, the chain is broken
and the error is returned by the "Unwrap" method:

	raiseError := func ()      (int, error) { return 0, errors.New("generic error") }
	plus2      := func (x int)              { return x + 2 }

	chainable.New().
		Chain(raiseError). // breakes the chain
		Chain(plus2).      // never called
		Unwrap()           // returns nil, "a generic error"

If automatic error handling isn't desired (i.e. the error should be chained along with the other arguments),
the method "ChainDummy" should be used instead of "Chain". Pay attention that the next function in the chain
must be able to receive the error generated by the previous one:

	raiseError    := func ()               (int, error) { return 2, errors.New("generic error") }
	plus2AndError := func (x int, e error) (int)        { return x + 2 }

	chainable.New().
		ChainDummy(raiseError).
		Chain(plus2AndError).
		Unwrap() // returns []interface{4}, nil

"Chain" and "DummyChain" methods are variadics, and can be used in conjunction:

	chainable.New().
		Chain(f1).       // error handling enabled for f1
		ChainDummy(f2).  // error handling disabled for f2
		Chain(f3, f4).   // error handling enabled for f3 and f4
		Unwrap()

Finally, to reset a chain and make it ready to be reused, just call the method "Reset":

	chain := chainable.New()

	... use of chain

	chain.Reset()
*/
package chainable

import (
	"errors"
	"reflect"
)

var (
	errNotAFunction     = errors.New("fn is not a function")
	errArgumentMismatch = errors.New("fn argument mismatch")
)

// Chainable defines the chain logic.
type Chainable struct {
	from  []interface{}
	links []link
}

// link represents a function in a chain
type link struct {
	fn          interface{}
	handleError bool
}

// New instantiate a new Chainable instance
func New() *Chainable {
	return &Chainable{}
}

// From defines the arguments provided to the first
// function in a chain
func (c *Chainable) From(args ...interface{}) *Chainable {
	c.from = args
	return c
}

// Chain appends a new function to the chain, with error
// handling enabled
func (c *Chainable) Chain(funcs ...interface{}) *Chainable {
	for _, fn := range funcs {
		c.addFunc(fn, true)
	}
	return c
}

// ChainDummy appends a new function to the chain, with error
// handling disabled
func (c *Chainable) ChainDummy(funcs ...interface{}) *Chainable {
	for _, fn := range funcs {
		c.addFunc(fn, false)
	}
	return c
}

// Unwrap process the chain.
// It returns a []interface{} with the arguments returned by the last function in the chain (or nil, if the chain is broken)
// and an error, returned by any of the functions in the chain with error-handling enabled (or nil, if success)
func (c *Chainable) Unwrap() ([]interface{}, error) {
	v := c.from
	var err error

	for _, link := range c.links {
		if v, err = processLink(link, v); err != nil {
			return nil, err
		}
	}

	return v, nil
}

// Reset cleanups a chain, removing all
// the links and initial values
func (c *Chainable) Reset() *Chainable {
	c.from = []interface{}{}
	c.links = []link{}

	return c
}

// addFunc add a new function to the chain, creating the underlying link
func (c *Chainable) addFunc(fn interface{}, handleError bool) {
	c.links = append(c.links, link{
		fn:          fn,
		handleError: handleError,
	})
}

// processLink calls the function fn associated to the link, transforming args using reflection
func processLink(lk link, args []interface{}) ([]interface{}, error) {
	vfn := reflect.ValueOf(lk.fn)
	vfnType := vfn.Type()

	// check if it's a function
	if vfnType.Kind() != reflect.Func {
		return nil, errNotAFunction
	}

	// check if args matches the function arity
	if !vfnType.IsVariadic() && (vfnType.NumIn() != len(args)) {
		return nil, errArgumentMismatch
	}

	// call the function
	out := []interface{}{}
	for _, o := range vfn.Call(reflectArgs(args)) {
		out = append(out, o.Interface())
	}

	// if the last returned value for the function
	// is an error, cast the error and return it
	// along with the rest of values
	if lk.handleError && doesReturnError(vfnType) {
		err, _ := out[len(out)-1].(error)
		return out[:len(out)-1], err
	}

	return out, nil
}

// reflectArgs transforms the args list in a list of
// reflect.Value, used to call a function using reflection
func reflectArgs(args []interface{}) []reflect.Value {
	in := make([]reflect.Value, len(args))

	for k, arg := range args {
		in[k] = reflect.ValueOf(arg)
	}

	return in
}

// doesReturnError returns true if the last return
// value for vfn is a type error
func doesReturnError(vfnType reflect.Type) bool {
	return vfnType.Out(vfnType.NumOut()-1) == reflect.TypeOf((*error)(nil)).Elem()
}
