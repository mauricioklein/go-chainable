# Go-chainable

[![Build Status](https://travis-ci.org/mauricioklein/go-chainable.svg?branch=master)](https://travis-ci.org/mauricioklein/go-chainable)
[![Maintainability](https://api.codeclimate.com/v1/badges/e00a9b448408857da9b6/maintainability)](https://codeclimate.com/github/mauricioklein/go-chainable/maintainability)
[![Test Coverage](https://api.codeclimate.com/v1/badges/e00a9b448408857da9b6/test_coverage)](https://codeclimate.com/github/mauricioklein/go-chainable/test_coverage)
[![GoDoc](https://godoc.org/github.com/mauricioklein/go-chainable?status.svg)](https://godoc.org/github.com/mauricioklein/go-chainable)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Provides an easy and convenient way of chaining function calls in Golang, with support to argument's feedback and error-handling

## Requirements

- Go 1.6 or later

## Installation

```go
go get github.com/mauricioklein/go-chainable
```

## Basics

It's common to find Go programs similar to the one below:

```go
x, err := sum2(2)
if err != nil {
    return 0, err
}

y, err = mul2(x)
if err != nil {
    return 0, err
}

z, err = div2(y)
if err != nil {
    return 0, err
}

return z, nil
```

Error handling can make the codebase messy. At the same time, chaining function calls can obfuscate
errors and cascading calls can increase the cognitive complexity.

`Elixir`, `F#` and other languages solve this problem with the support to pipes, but Golang hasn't such
feature.

Chainable provides a clearer way to chain function calls, using the output of the previous function
as the input of the next one. 

The example above could be re-written using Chainable as follow:

```go
import (chainable "github.com/mauricioklein/go-chainable")

res, err := chainable.New().
    From(2).
    Chain(
        sum2,
        mul2,
        div2,
    ).
    Unwrap()

// "Unwrap" returns the result as a slice of Argument, matching the return values
// of the last function. So, we just need to cast them to the correct type
z := res[0].(int)
```

Another advantage is that Chainable automatically handle errors in a chain.

Thus, if one of the methods returns an error as the last argument, the chain is broken
and the error is returned by the "Unwrap" method:

```go
raiseError := func ()      (int, error) { return 0, errors.New("generic error") }
plus2      := func (x int)              { return x + 2 }

chainable.New().
    Chain(raiseError). // breakes the chain
    Chain(plus2).      // never called
    Unwrap()           // returns nil, "a generic error"
```

If automatic error handling isn't desired (i.e. the error should be chained along with the other arguments),
the method "ChainDummy" should be used instead of "Chain"
(pay attention that the next function in the chain
must be able to receive the error generated by the previous one):

```go
raiseError    := func ()               (int, error) { return 2, errors.New("generic error") }
plus2AndError := func (x int, e error) (int)        { return x + 2 }

chainable.New().
    ChainDummy(raiseError).
    Chain(plus2AndError).
    Unwrap() // returns []Argument{4}, nil
```

"Chain" and "DummyChain" methods are variadics, and can be used in conjunction:

```go
chainable.New().
    Chain(f1).       // error handling enabled for f1
    ChainDummy(f2).  // error handling disabled for f2
    Chain(f3, f4).   // error handling enabled for f3 and f4
    Unwrap()
```

Finally, to reset a chain and make it ready to be reused, just call the method "Reset":

```go
chain := chainable.New()

// ... use of chain

chain.Reset()
```

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request
